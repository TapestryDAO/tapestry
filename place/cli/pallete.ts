import yargs, { ArgumentsCamelCase, Argv, boolean, number, string } from "yargs";
import * as fs from "fs";
import { argv } from "process";
import path from "path";
import { TAPESTRY_ROOT } from "../../cli_utils/utils";

type ConvertHexToJsonCommandArgs = { inFile: string } & { name: string } & { rust: boolean } & {
    ts: boolean;
};

const PALLETE_OUT = path.resolve(TAPESTRY_ROOT, "place", "client", "src", "palletes");
const PALLETE_OUT_RUST = path.resolve(TAPESTRY_ROOT, "place", "watcher", "src");

const rgbStringToArayString = (color: string) => {
    let rString = color.substring(0, 2);
    let gString = color.substring(2, 4);
    let bString = color.substring(4, 6);

    let rValue = parseInt(rString, 16);
    let gValue = parseInt(gString, 16);
    let bValue = parseInt(bString, 16);

    return "&[" + rValue + ", " + gValue + ", " + bValue + "]";
};

const writeRustPallete = (name: string, hexPallete: string[]) => {
    let file_contents = "// Autogenerated file using pla pallete cli command\n\n";
    let struct_name = name.charAt(0).toUpperCase() + name.slice(1);
    let indent = "    ";
    file_contents += "pub struct " + struct_name + " {}\n\n";
    file_contents += "impl " + struct_name + " {\n";
    file_contents += indent + "pub fn u8_to_rgb(pixel: u8) -> &'static[u8; 3] {\n";
    file_contents += indent + indent + "match pixel {\n";

    for (let [idx, hex] of hexPallete.entries()) {
        file_contents +=
            indent + indent + indent + idx + " => " + rgbStringToArayString(hex) + ",\n";
    }

    // map any out of range value to the same color as 0
    file_contents +=
        indent + indent + indent + "_ => " + rgbStringToArayString(hexPallete[0]) + "\n";
    file_contents += indent + indent + "}\n";
    file_contents += indent + "}\n";
    file_contents += "}\n";

    let outfile = path.resolve(PALLETE_OUT_RUST, name + ".rs");
    console.log("Writing rust output to: ", outfile);
    fs.writeFileSync(outfile, file_contents, "utf8");
};

const convert_pallete_command = {
    command: "convert",
    description: "Convert .hex pallete to json and place at dstPath",
    builder: (args: Argv): Argv<ConvertHexToJsonCommandArgs> => {
        return args
            .option("inFile", {
                description: "Input file, should be a hex file",
                type: "string",
                required: true,
            })
            .option("name", {
                description: "pallete name",
                type: "string",
                required: true,
            })
            .option("rust", {
                description: "generate rust?",
                type: "boolean",
                default: false,
            })
            .option("ts", {
                description: "generate typescript?",
                type: "boolean",
                default: false,
            });
    },
    handler: async (args: ArgumentsCamelCase<ConvertHexToJsonCommandArgs>) => {
        const data = fs.readFileSync(args.inFile, "utf8");
        const hexValues = data
            .split("\n")
            .map((value) => value.trim())
            .filter((value) => value != "");

        if (hexValues.length > 256) {
            throw Error("Invalid hex file, too many colors");
        }

        console.log("Hex file had ", hexValues.length, " colors");

        if (args.ts) {
            console.log("Writing typescript json array to ", args.outFile);
            let typescriptFileContents =
                "export const " + args.name + " = " + JSON.stringify(hexValues);
            let outfile = path.resolve(PALLETE_OUT, args.name + ".ts");
            fs.writeFileSync(outfile, typescriptFileContents, "utf8");
        }

        if (args.rust) {
            writeRustPallete(args.name, hexValues);
        }
    },
};

export const command = {
    command: "pallete",
    desctiption: "Pallete helpers",
    builder: (argv: Argv) => {
        return argv.command(convert_pallete_command).demandCommand();
    },
};
